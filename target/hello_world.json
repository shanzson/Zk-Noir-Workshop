{"noir_version":"0.31.0+540bef3597bd3e5775c83ec2ee3c0d4463084b4c","hash":8652463845999645816,"abi":{"parameters":[{"name":"items","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Item","fields":[{"name":"price","type":{"kind":"field"}},{"name":"quantity","type":{"kind":"field"}},{"name":"cost","type":{"kind":"field"}}]}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+VaW47bIBTF9iQh74fa/ywBjI3xX9pd9NMPLPWnqqqur0urajJ254YhrdNcrIyKFEEwPufcczEmKAF5Lu/az3vyUoKuPnU1u6/wHtPGFUwmic5izQUvWJyXKmVJWkrFFU9VWsdKCK0SleVlnrGcJ0LzJs1F0wGHeBqZj7ijFuPJQ9wTxLgnVs5hCZH9QMwXx/SAXPMAU2wADP2fTUbwl9sd0NdZV1OfCTXAUUf2oyOKOtKTxfn0RhJ846rErFWJzwjeCkeJn4mH/bBhxjz/A5bKdNlkiShY0pQtjmy0KOKcN0q08CLhZaFZnZSZTKRqsvOqHhL3qo79lpvjYTGod0E8PsC+jFh4wF0iTjJfcS/xc+TUirGwGK33LgQ2LmaOVgT3gTIvJoP5of1Muu+unYgPr/8xDvsNrxxyvewe1l29ISPsHtbk5XdR1JGeLM7IY1LufeOvEXVtkCeLPZk5003Lzytd81RnaTssznRVFXUqirIsRJKpVlWVt2g6k5IVTZpVaRHXuSlFCPKFmY8t8btg3hv3xFPcO+S4+2Lvtnm7bZJScB5L1m6T2i1SVVdS53US10VVxI0oy1Q2pValUnlcCqWrLBd5FctzCRGxEH9O8S1iLvaecmGvXey+wqeIWIjzj2P6F4A5PAVe9scH/ZnSxLpmj/8N8qmrKbh2xBKsnpPSg9tvTLjT6sfMgHhjXEAv76HkZeIEBC9JFBh0RMPl553f02UIr3w4gvYUxDlB1+MrzueNAzxbwcHNyoC8npv2A7ABY6AG6sG/gFw+SEcrZzY3nhdxbLjnA7yYO/TMR/Zi7uDG80Ke58VigBcLh57FyF4sHNyIXuSGeznAi6VDz3JkL5YObkQvtOFeDfBi5dCzGtmLlYMb0YvEcK8HeLF26FmP7EXPd6tm+gCaqdXG4RZF0MX6Ny82Dj2bkb3o+W7VTB9AM7XaONxSGu7tAC+2Dj3bkb3o+W7VvHgAzdRq43DL1HDvBnixc+jZjezFzsGN6EVluPcDvNg79OxH9qLnu1Xz6g1qpg+gmVptHO6sNtyHAV4cHHoOI3txANx9H+L5BDPrbH8e8PXb5y/fiVXgIUME2iEQ04+Bi9rUcX/Q1T/J5T+z+gB31tg5wJk6uImjz8UH2yG51G5fd/UtHTx7R9/MoRXimULBeOPDqWuzO4vB6PMzcWh7AtfhwUKAr4XDeCPy2oO9wx9qaYPar3035SO5/M9BAPoDcE/U9dm8cB6GAO/amOAKztA58gsCQtXc/igAAA==","debug_symbols":"ndjLasJAFIDhd5m1lMw5Zy76KqWUeCuCRNFYKOK7N9bahQ3I+Xc5mfxkMd9m5hyWq/np433TrXfHMHs9h+1u0fabXTdM59D8vDru2+46Hfv20IeZNjIJq245PGm5TMJ6s12FmdXL2yREbyBjgTX5NzBpHgIdDTTeA9OHwLxB8gbZGxRvUL3B1BvExl1EdyHu4tlu53+FuYvkLrK3kJfRnxS5Oy8p/iXa3JLsT4o/qf5k6k/GeT1pImgENAoaAw0wEAGCCBREwCACBwIcCHAgwIEABwIcCHAgwIEABwIcCHCgwIECBwocKHCgwIECBwocKHCgwIECBwYcGHBgwIEBBwYcGHBgwIEBBwYcGHCQgIMEHCTgIAEHCThIwEECDhJwkICDBBxk4CADBxk4yMBBBg4yOSsABxk4yMBBBg4KcFCAgwIcFOCgAAcFOCjk0AgcFOCgAAcVOKjAQQUOKnBQgYMKHFTgoDodDMNne9i08+3qell4XTt1i/vd4TD2X/vbyvDtNw==","file_map":{"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"48":{"source":"use dep::std;\n\nglobal RATE_IN_PERCENT = 5;\nglobal MIN_TAX_THRESHOLD = 8;\n\nstruct Item {\n    price: Field,\n    quantity: Field,\n    cost: Field,\n}\n\nimpl Item {\n    fn check_cost(self) -> bool {\n        self.price * self.quantity == self.cost\n    }\n}\n\nfn main(items: [Item; 2]) -> pub Field {\n    assert(items.all(|i: Item| i.check_cost())); \n    \n    let total = items.fold(0, |x, i: Item| x + i.cost);\n    println(total);\n\n    if (total as u64 > MIN_TAX_THRESHOLD){\n        total + total * RATE_IN_PERCENT / 100\n    }\n    else {\n        total\n    }\n}\n\n#[test]\nfn test_main() {\n    let item1 = Item { price: 1, quantity: 1, cost: 1 };\n    let item2 = Item { price: 2, quantity: 4, cost: 8 };\n    \n    let total = main([item1, item2]);\n    println(total);\n    // assert(total == 18967536818011759742494742649109346476339598193270847513121495473105084380374 );\n}\n","path":"/Users/shanzson/Code/zk-workshop/hello_world/src/main.nr"}},"names":["main"]}